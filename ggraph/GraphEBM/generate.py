
### Code adapted from MoFlow (under MIT License) https://github.com/calvin-zcx/moflow
import re
import numpy as np
from rdkit import Chem
import networkx as nx
from aig_config import *
#
# NUM2EDGETYPE = {
#     0: "EDGE_REG",  # Index 0 feature
#     1: "EDGE_INV",   # Index 1 feature
# }

#TODO figureout equivalent
ATOM_VALENCY = {6: 4, 7: 3, 8: 2, 9: 1, 15: 3, 16: 2, 17: 1, 35: 1, 53: 1}

bond_decoder_m = {1: "EDGE_REG", 2: "EDGE_INV", 3: "NONE"}
#bond_decoder_m = {1: Chem.rdchem.BondType.SINGLE, 2: Chem.rdchem.BondType.DOUBLE, 3: Chem.rdchem.BondType.TRIPLE}

# Define one-hot encodings (Keep these hardcoded as they define the feature representation)
NODE_TYPE_ENCODING_PYG = {
    # Map "NODE_CONST0" to the first encoding vector (index 0), etc.
    "NODE_CONST0": 0, # Index 0 feature
    "NODE_PI":     1, # Index 1 feature
    "NODE_AND":    2, # Index 2 feature
    "NODE_PO":     3,  # Index 3 feature,
    "VIRTUAL": 4
}

def construct_aig(x, A, node_type_list=NODE_TYPE_KEYS):
    #mol = Chem.RWMol()
    # N, Atom Types + 1 is X and A is N, 3
    aig = nx.DiGraph()
    #atoms = np.argmax(x, axis=1)
    node_type_indices_all = np.argmax(x, axis=1)
    pad_node_type_index = len(node_type_list) - 1
    active_node_mask = node_type_indices_all != pad_node_type_index
    #atoms_exist = atoms != len(atomic_num_list) - 1
    #atoms = atoms[atoms_exist]
    active_nodes = node_type_indices_all[active_node_mask]

    #for atom in atoms:
    for i, assigned_type_idx in enumerate(active_nodes):
        #mol.AddAtom(Chem.Atom(int(atomic_num_list[atom])))
        node_type = node_type_list[assigned_type_idx]
        aig.add_node(i, type=node_type)

    # A (edge_type, num_node, num_node)
    adj = np.argmax(A, axis=0)
    adj = np.array(adj)
    filtered_adj = adj[active_node_mask, :][:, active_node_mask]
    # adj[adj == 3] = -1
    # adj += 1
    for start, end in zip(*np.nonzero(adj)):
        if start > end:
            edge_type_idx = filtered_adj[start, end]
            aig.add_edge(int(start), int(end), type=bond_decoder_m[int(edge_type_idx)]) #??
            #mol.AddBond(int(start), int(end), bond_decoder_m[adj[start, end]])

    return aig


def check_valency(mol):
    """
    Checks that no atoms in the mol have exceeded their possible
    valency
    :return: True if no valency issues, False otherwise
    """
    try:
        Chem.SanitizeMol(mol, sanitizeOps=Chem.SanitizeFlags.SANITIZE_PROPERTIES)
        return True, None
    except ValueError as e:
        e = str(e)
        p = e.find('#')
        e_sub = e[p:]
        atomid_valence = list(map(int, re.findall(r'\d+', e_sub)))
        return False, atomid_valence

# prev correct_mol
def correct_fanins(aig):
    if check_valency(aig):
        return aig
    for node_id, node_data in aig.nodes(data=True):
        node_type = node_data.get('type')
        if node_type == "NODE_CONST0" or node_type == "NODE_PI":
            if any(aig.predecessors(node_id)):
                for source in aig.predecessors(node_id):
                    aig.remove_edge(source, node_id)
        elif node_type == "NODE_PO":
            if any(aig.successors(node_id)):
                for target in aig.successors(node_id):
                    aig.remove_edge(node_id, target)
            if len(aig.predecessors(node_id)) > 1:


        if node_type == "NODE_AND" and aig.predecessors(node_id) > 2:



    while True:
        if check_validity(aig):
            break
        else:
            assert len(atomid_valence) == 2
            idx = atomid_valence[0]
            queue = []
            for b in mol.GetAtomWithIdx(idx).GetBonds():
                queue.append(
                    (b.GetIdx(), int(b.GetBondType()), b.GetBeginAtomIdx(), b.GetEndAtomIdx())
                )
            queue.sort(key=lambda tup: tup[1], reverse=True)
            if len(queue) > 0:
                start = queue[0][2]
                end = queue[0][3]
                t = queue[0][1] - 1
                mol.RemoveBond(start, end)
                if t >= 1:
                    mol.AddBond(start, end, bond_decoder_m[t])
    return mol


def valid_mol_can_with_seg(x, largest_connected_comp=True):
    # mol = None
    if x is None:
        return None
    sm = Chem.MolToSmiles(x, isomericSmiles=True)
    mol = Chem.MolFromSmiles(sm)
    if largest_connected_comp and '.' in sm:
        vsm = [(s, len(s)) for s in sm.split('.')]  # 'C.CC.CCc1ccc(N)cc1CCC=O'.split('.')
        vsm.sort(key=lambda tup: tup[1], reverse=True)
        mol = Chem.MolFromSmiles(vsm[0][0])
    return mol


def gen_mol_from_one_shot_tensor(adj, x, largest_connected_comp=True):
    r"""Construct molecules from the node tensors and adjacency tensors generated by one-shot molecular graph generation methods.

    Args:
        adj (Tensor): The adjacency tensor with shape [:obj:`number of samples`, :obj:`number of possible bond types`, :obj:`maximum number of atoms`, :obj:`maximum number of atoms`].
        x (Tensor): The node tensor with shape [:obj:`number of samples`, :obj:`number of possible atom types`, :obj:`maximum number of atoms`].
        atomic_num_list (list): A list to specify what atom each channel of the 2nd dimension of :obj: `x` corresponds to.
        correct_validity (bool, optional): Whether to use the validity correction introduced by the paper `MoFlow: an invertible flow model for generating molecular graphs <https://arxiv.org/pdf/2006.10137.pdf>`_. (default: :obj:`True`)
        largest_connected_comp (bool, optional): Whether to use the largest connected component as the final molecule in the validity correction.(default: :obj:`True`)

    :rtype: A list of rdkit mol object. The length of the list is :obj:`number of samples`.

    Examples
    # --------
    # >>> adj = torch.rand(2, 4, 38, 38)
    # >>> x = torch.rand(2, 10, 38)
    # >>> atomic_num_list = [6, 7, 8, 9, 15, 16, 17, 35, 53, 0] [0,1,2,3]? for my case?
    # >>> gen_mols = gen_mol_from_one_shot_tensor(adj, x, atomic_num_list)
    # >>> gen_mols
    [<rdkit.Chem.rdchem.Mol>, <rdkit.Chem.rdchem.Mol>]
    """
    x = x.permute(0, 2, 1) # Now B, N, Atom Types + 1
    adj = adj.cpu().detach().numpy()
    x = x.cpu().detach().numpy()
    # if not correct_validity:
    #     gen_mols = [construct_mol(x_elem, adj_elem, atomic_num_list) for x_elem, adj_elem in zip(x, adj)]
    # else:
    gen_graphs = []
    # TODO I think atomic num list should be 0, 1, 2, 3, 4 where 4 is virtual?
    for x_elem, adj_elem in zip(x, adj):
        aig = construct_aig(x_elem, adj_elem)
        cmol = correct_fanins(aig)
        vcmol = valid_mol_can_with_seg(cmol, largest_connected_comp=largest_connected_comp)
        gen_graphs.append(vcmol)

    return gen_graphs, 0
